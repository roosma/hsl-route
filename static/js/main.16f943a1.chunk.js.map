{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapConfig","url","attribution","center","zoomLevel","style","height","RealtimeMarkers","_ref","vehicles","data","map","item","VP","filter","lat","long","reduce","res","veh","tsi","Object","values","vehicle","icon","divIcon","className","html","concat","desi","display","iconAnchor","iconSize","react_default","a","createElement","Marker","position","key","App","Map","zoom","fullscreenControl","TileLayer","App_RealtimeMarkers","this","props","Component","subscribe","topic","Boolean","window","location","hostname","match","ReactDOM","render","lib","mqttProps","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qTAOMA,UAAY,CAChBC,IAAK,qEACLC,YAAa,+HACbC,OAAQ,CAAE,OAAQ,QAClBC,UAAW,GACXC,MAAO,CAAEC,OAAQ,UAGbC,EAAkB,SAAAC,GAAc,IAC9BC,EAD8BD,EAAXE,KAEtBC,IAAI,SAAAC,GAAI,OAAIA,EAAKC,KACjBC,OAAO,SAAAF,GAAI,OAAIA,EAAKG,KAAOH,EAAKI,OAChCC,OAAO,SAACC,EAAKN,GAIZ,QAHKM,EAAIN,EAAKO,MAAQP,EAAKQ,IAAMF,EAAIN,EAAKO,KAAKC,OAC7CF,EAAIN,EAAKO,KAAOP,GAEXM,GACN,IAEL,OAAIT,EACKY,OAAOC,OAAOb,GAAUE,IAAI,SAAAY,GACjC,IACMC,EAAOC,kBAAQ,CACnBC,UAAW,iBACXC,KAAI,mDAAAC,OAHW,GAGmD,IAA9D,qBAAAA,OAHW,GAGX,SAAAA,OAAqGL,EAAQM,KAA7G,UACJxB,MAAO,CACLyB,QAAS,QAEXC,WAAY,CAACC,GAAYA,IACzBA,SAAU,CARK,SAUjB,OACEC,EAAAC,EAAAC,cAACC,EAAA,EAAD,CAAQZ,KAAMA,EAAMa,SAAU,CAACd,EAAQR,IAAKQ,EAAQP,MAAOsB,IAAKf,EAAQJ,QAKvE,MAGHoB,mLAIF,OACEN,EAAAC,EAAAC,cAAA,OAAKT,UAAU,OACbO,EAAAC,EAAAC,cAACK,EAAA,EAAD,CACErC,OAAQH,EAAUG,OAClBsC,KAAMzC,EAAUI,UAChBC,MAAOL,EAAUK,MACjBqC,mBAAiB,GAEjBT,EAAAC,EAAAC,cAACQ,EAAA,EAAD,CAAW1C,IAAKD,EAAUC,IAAKC,YAAaF,EAAUE,cACtD+B,EAAAC,EAAAC,cAACS,EAAD,CAAiBlC,KAAMmC,KAAKC,MAAMpC,gBAb1BqC,aAoBHC,sBAAU,CACvBC,MAAO,CACL,4CACA,4CACA,6CACA,8CALWD,CAQZT,GC/DiBW,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCVNC,IAASC,OACPvB,EAAAC,EAAAC,cAACsB,EAAA,UAAD,CAAWC,UAAU,0BACnBzB,EAAAC,EAAAC,cAACwB,EAAD,OAEFC,SAASC,eAAe,SDqHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.16f943a1.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport { subscribe } from 'mqtt-react';\nimport { Map, TileLayer, Marker } from 'react-leaflet';\nimport { divIcon } from 'leaflet';\n\nimport './App.css';\n\nconst mapConfig = {\n  url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}{r}.png',\n  attribution: '<a href=\"http://stamen.com\">Stamen Design</a> | <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> | HSL-map',\n  center: [ 60.162, 24.688 ],\n  zoomLevel: 14,\n  style: { height: '100%' },\n};\n\nconst RealtimeMarkers = ({ data }) => {\n  const vehicles = data\n    .map(item => item.VP)\n    .filter(item => item.lat && item.long)\n    .reduce((res, item) => {\n      if (!res[item.veh] || item.tsi > res[item.veh].tsi) {\n        res[item.veh] = item;\n      }\n      return res;\n    }, {});\n\n  if (vehicles) {\n    return Object.values(vehicles).map(vehicle => {\n      const iconSize = 26;\n      const icon = divIcon({\n        className: 'vehicle-marker',\n        html: `<div style=\"background-color: black; font-size: ${iconSize*.45}px; line-height: ${iconSize}px;\">${vehicle.desi}</div>`,\n        style: {\n          display: 'none',\n        },\n        iconAnchor: [iconSize/2, iconSize/2],\n        iconSize: [iconSize, iconSize],\n      });\n      return (\n        <Marker icon={icon} position={[vehicle.lat, vehicle.long]} key={vehicle.veh} />\n      );\n    });\n  }\n\n  return null;\n}\n\nclass App extends Component {\n  render() {\n\n\n    return (\n      <div className=\"app\">\n        <Map\n          center={mapConfig.center}\n          zoom={mapConfig.zoomLevel}\n          style={mapConfig.style}\n          fullscreenControl\n        >\n          <TileLayer url={mapConfig.url} attribution={mapConfig.attribution}/>\n          <RealtimeMarkers data={this.props.data} />\n        </Map>\n      </div>\n    );\n  }\n}\n\nexport default subscribe({\n  topic: [\n    '/hfp/v2/journey/ongoing/vp/+/+/+/2157/2/#',\n    '/hfp/v2/journey/ongoing/vp/+/+/+/2124/2/#',\n    '/hfp/v2/journey/ongoing/vp/+/+/+/2124K/2/#',\n    '/hfp/v2/journey/ongoing/vp/+/+/+/2510/2/#',\n    //<prefix>/<version>/<journey_type>/<temporal_type>/<event_type>/<transport_mode>/<operator_id>/<vehicle_number>/<route_id>/<direction_id>/<headsign>/<start_time>/<next_stop>/<geohash_level>/<geohash>/#\n  ],\n})(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Connector } from 'mqtt-react';\n\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <Connector mqttProps=\"wss://mqtt.hsl.fi:443/\">\n    <App />\n  </Connector>,\n  document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}